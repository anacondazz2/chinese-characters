Do you need both package-lock.json and package.json? No.
Do you need the package.json? Yes.
Can you have a project with only the package-lock.json? No.
The package.json is used for more than dependencies - like defining project properties, description, author & license information, scripts, etc. The package-lock.json is solely used to lock dependencies to a specific version number.

regex patterns should be raw strings so that the backslashes are included. a\+b\* would be interpreted as literal sequence a+b* where + and * are not treated as special regex characters. Take r'^a\+b\*[a-zA-Z]*[1-5]?$'. The remaining parts like [1-5]? will be interpreted as proper regex.

raw strings cancel the backslash escape functionality.

confusing because n has no special meaning but \n has special meaning but in regex ? has special meaning while escaping it \? removes that meaning and turns it a literal ?.

json keys must be strings. python dict keys can be either string, number, or a tuple can be a key.

* When importing from a python file, all top level code not in a function body will run.

.filter in Django returns a QuerySet of each of the Word models. Serializer expects to take in a list of models with many=true arg.
returned serializer.data will be the JSON.

JSX elements are javascript objects.
JSX are the html stuff in the js file.
{} are used to go back to writing javascript within JSX.

.map() returns a new array with a function applied to each element.
const numbers = [65, 44, 12, 4];
const newArr = numbers.map(myFunction) // [650, 440, 120, 40]
function myFunction(num) {
  return num * 10;
}

When you pass an array of <li> elements to a <ul>, React automatically handles it by rendering each <li> as a child of the <ul>.
Which is why this works: <ul>
                            {displayResults.map((entry, index) => (
                            <li key={index}>
                                {entry.simplified}  {entry.pinyin}
                            </li>
                            ))}
                        </ul>

strings as the body of JSX will intuitively be body text.

.split() splits a string into an array of substrings.
.join() joins an array of substrings into a big string.

.replace() with a string pattern will only replace the first occurence.
use \g flag to replace all occurences.

any files we include in the pages folder will be a new url route. the api folder is for backend url requests.
files that start with an underscore such as _document.js will not create a path.

making an api handler using only js takes in both the req and res as arguments of the function.
ex: res.status(200).send("login page")
    res.write(# an entire login form's html)

field values in a form are by defualt empty string.

.get() in python to access a key's value in a dictionary is preferred over [] notation.

lexical scope is the outer scope. It is usually the most immediate parent scope. obviously all inner scopes can access their outer scopes. 

so a closure would be a function that retains access to variables from its LEXICAL scope, even after the outer function has finished executing.
